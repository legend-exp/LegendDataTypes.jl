var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LegendDataTypes]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#LegendDataTypes.RadwareSigcompress","page":"API","title":"LegendDataTypes.RadwareSigcompress","text":"RadwareSigcompress <: AbstractArrayCodec\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataTypes.TableLike","page":"API","title":"LegendDataTypes.TableLike","text":"TableLike = AbstractVector{<:NamedTuple}\n\nThe type must also support the Tables.jl interface.\n\nExamples are TypedTables.Table and StructArrays.StructArray\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.getindex-Tuple{AbstractLegendInput, AbstractString, Vararg{Any}}","page":"API","title":"Base.getindex","text":"getindex(input::AbstractLegendInput, key::AbstractString)\ngetindex(input::AbstractLegendInput, key::AbstractString, idxs::AbstractVector)\n\nGet object at key from input.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{LegendNullOutput, Any, AbstractString, Vararg{Any}}","page":"API","title":"Base.getindex","text":"setindex!(output::AbstractLegendOutput, key::AbstractString)\ngetindex(output::AbstractLegendOutput, key::AbstractString, idxs::AbstractVector)\n\nGet object at key from input.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.chname2int-Tuple{AbstractString}","page":"API","title":"LegendDataTypes.chname2int","text":"chname2int(channel_string::AbstractString)::Integer\n\nConvert a channel name string, as used in LEGEND data files to an integer channel number.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.decode_data","page":"API","title":"LegendDataTypes.decode_data","text":"decode_data(data)\n\nDecode any encoded arrays present in (possibly nested) data.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataTypes.fast_flatten","page":"API","title":"LegendDataTypes.fast_flatten","text":"fast_flatten(vector_of_arrays)\n\nFlattens a vector of arrays into a single array, by concatenating the inner arrays along the last dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataTypes.filter_raw_data_by_energy-Tuple{AbstractVector{<:NamedTuple}, Function, AbstractDict{Symbol, <:IntervalSets.AbstractInterval{<:Number}}}","page":"API","title":"LegendDataTypes.filter_raw_data_by_energy","text":"filter_raw_data_by_energy(\n    raw_data::TableLike,\n    calib_func::Function,\n    energy_windows::AbstractDict{Symbol,<:AbstractInterval{<:Number}}\n)::IDDict{Symbol,<:Any}\n\nFilter the table raw data, selecing only events in the energy intervals in values(energy_windows).\n\nThe selection is based on DAQ energy reconstruction and the energy calibration function calib_func.\n\nReturns a dicts of raw data tables with the same keys as energy_windows.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.flatten_by_key-Tuple{AbstractVector{<:IdDict{<:Any, <:AbstractVector}}}","page":"API","title":"LegendDataTypes.flatten_by_key","text":"flatten_by_key(data::AbstractVector{<:IdDict{<:Any, <:AbstractVector}})::IdDict\n\nFlattens a vector of IdDicts into a single IdDict, by concatenating the entries for each key separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.get_all_channels-Tuple{AbstractDict{<:AbstractString}}","page":"API","title":"LegendDataTypes.get_all_channels","text":"get_all_channels(ds::AbstractDict{<:AbstractString,<:Any})::AbstractVector{<:Integer}\n\nGet the channel numbers for all channels in datastore.\n\nChannels are identified as keys starting with \"ch...\", according to LEGEND convention. datastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore.\n\nChannel named are mapped to integer channel numbers via chname2int.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.get_daqenergy-Tuple{AbstractDict{<:AbstractString}, Integer}","page":"API","title":"LegendDataTypes.get_daqenergy","text":"get_daqenergy(datastore::AbstractDict{<:AbstractString,<:Any}, ch::Integer)::AbstractVector{<:Integer}\n\nGet the daq energy reconstruction contained in the raw data of channel ch in datastore.\n\ndatastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore. Channel numbers are mapped to channel names via int2chname.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.get_raw_ch_data-Tuple{AbstractDict{<:AbstractString}, Integer}","page":"API","title":"LegendDataTypes.get_raw_ch_data","text":"get_raw_ch_data(ds::AbstractDict{<:AbstractString,<:Any}, ch::Integer)::TableLike\n\nGet the raw data table for channel ch in datastore.\n\ndatastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore. Channel numbers are mapped to channel names via int2chname.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.getunits","page":"API","title":"LegendDataTypes.getunits","text":"getunits(x)\n\nGet the units of x, falls back to Unitful.unit(x) if no specialized method is defined for the type of x.\n\nLEGEND I/O packages shoud add methods for the I/O-object types they handle.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataTypes.int2chname-Tuple{Any}","page":"API","title":"LegendDataTypes.int2chname","text":"int2chname(channel_number::Integer)::AbstractString\n\nConvert an integer channel number to a channel name string as used in LEGEND data files.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.map_chunked-Tuple{Any, Any, Integer}","page":"API","title":"LegendDataTypes.map_chunked","text":"map_chunked(f, table, chunk_size::Integer)\n\nMaps a function f over a table in chunks of size chunk_size.\n\nCalls getindex with contiguous index ranges, and so is also efficient for disk-based arrays and similar arrays with slow serial indexing but fast block-wise indexing.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataTypes.read_from_properties","page":"API","title":"LegendDataTypes.read_from_properties","text":"read_from_properties(read_property::Function, src::Any, ::Type{T}) where {T<:AbstractArrayCodec}\n\nCreate a array codec of type T from properties of src, using the src-specific function read_property(src, name::Symbol, default_value) to read each property required.\n\nReturns an value of type T.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataTypes.readdata","page":"API","title":"LegendDataTypes.readdata","text":"readdata(input, SomeDataType::Type)\n\nRead a value of type SomeDataType from input.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataTypes.setunits!","page":"API","title":"LegendDataTypes.setunits!","text":"setunits!(x)\n\nSet the units of x.\n\nLEGEND I/O packages will need to add methods for the I/O-object types they handle.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataTypes.to_properties","page":"API","title":"LegendDataTypes.to_properties","text":"write_to_properties!(write_property!::Function, dest::Any, codec::AbstractArrayCodec)\n\nWrite all information required to re-create codec to dest using thes dest-specific function write_property!(dest, name::Symbol, x).\n\nTypically returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataTypes.writedata","page":"API","title":"LegendDataTypes.writedata","text":"readdata(input, x::SomeDataType)\n\nWrite a value x to output.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendDataTypes.jl","page":"Home","title":"LegendDataTypes.jl","text":"","category":"section"}]
}
